name: Deploy AKS Predictor

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:  # Manual trigger

env:
  RESOURCE_GROUP: rg-aks-predictor
  AKS_CLUSTER: aks-predictor-cluster
  ACR_NAME: acrpredictorlab13224  # Your ACR name
  APP_NAME: aks-predictor
  LOCATION: eastus

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: Prod
    
    steps:
    - name: ğŸ›’ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ” Azure Login
      uses: azure/login@v1
      with:
        creds: |
          {
            "clientId": "${{ secrets.CLIENT_ID }}",
            "clientSecret": "${{ secrets.CLIENT_SECRET }}",
            "subscriptionId": "${{ secrets.SUBSCRIPTION_ID }}",
            "tenantId": "${{ secrets.TENANT_ID }}"
          }

    - name: ğŸ—ï¸ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ğŸ“¦ Login to ACR
      run: |
        az acr login --name ${{ env.ACR_NAME }}

    - name: ğŸ·ï¸ Generate image tag
      id: image-tag
      run: |
        if [ "${{ github.event_name }}" == "pull_request" ]; then
          echo "tag=pr-${{ github.event.number }}" >> $GITHUB_OUTPUT
        else
          echo "tag=v${{ github.run_number }}" >> $GITHUB_OUTPUT
        fi

    - name: ğŸ³ Build and push Docker image
      run: |
        cd app
        docker build -t ${{ env.ACR_NAME }}.azurecr.io/${{ env.APP_NAME }}:${{ steps.image-tag.outputs.tag }} .
        docker push ${{ env.ACR_NAME }}.azurecr.io/${{ env.APP_NAME }}:${{ steps.image-tag.outputs.tag }}

    - name: â˜¸ï¸ Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'

    - name: ğŸ”— Get AKS credentials
      run: |
        az aks get-credentials --resource-group ${{ env.RESOURCE_GROUP }} --name ${{ env.AKS_CLUSTER }} --overwrite-existing

    - name: ğŸš€ Deploy to AKS
      run: |
        # Replace image tag in deployment
        sed -i "s|IMAGE_TAG|${{ steps.image-tag.outputs.tag }}|g" k8s/deployment.yaml
        sed -i "s|ACR_NAME|${{ env.ACR_NAME }}|g" k8s/deployment.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f k8s/deployment.yaml
        
        # Wait for rollout
        kubectl rollout status deployment/aks-predictor-dashboard --timeout=300s

    - name: ğŸ“Š Get deployment info
      run: |
        echo "ğŸ‰ Deployment completed!"
        echo "ğŸ“± Pods:"
        kubectl get pods -l app=aks-predictor
        echo "ğŸŒ Service:"
        kubectl get service aks-predictor-service
        echo "ğŸ”— External IP:"
        kubectl get service aks-predictor-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}'

    - name: ğŸ§ª Health check
      run: |
        EXTERNAL_IP=$(kubectl get service aks-predictor-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        if [ -n "$EXTERNAL_IP" ]; then
          echo "Testing health endpoint..."
          for i in {1..30}; do
            if curl -f "http://$EXTERNAL_IP/health" > /dev/null 2>&1; then
              echo "âœ… Health check passed!"
              echo "ğŸŒ Dashboard available at: http://$EXTERNAL_IP"
              break
            fi
            echo "â³ Waiting for service to be ready... ($i/30)"
            sleep 10
          done
        fi